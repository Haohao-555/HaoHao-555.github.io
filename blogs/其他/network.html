<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端 计算机网络篇 | усилの博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/avatar.png">
    <meta name="description" content="The heart wants to persevere">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.c33c50c5.css" as="style"><link rel="preload" href="/assets/js/app.7286f64f.js" as="script"><link rel="preload" href="/assets/js/3.827211db.js" as="script"><link rel="preload" href="/assets/js/1.5fd42fbd.js" as="script"><link rel="preload" href="/assets/js/61.2ae32b4f.js" as="script"><link rel="prefetch" href="/assets/js/10.0fdf308a.js"><link rel="prefetch" href="/assets/js/11.bd878a1a.js"><link rel="prefetch" href="/assets/js/12.0ac31588.js"><link rel="prefetch" href="/assets/js/13.b3520757.js"><link rel="prefetch" href="/assets/js/14.1a1abbe5.js"><link rel="prefetch" href="/assets/js/15.0f844592.js"><link rel="prefetch" href="/assets/js/16.4d5cd4c1.js"><link rel="prefetch" href="/assets/js/17.f970247f.js"><link rel="prefetch" href="/assets/js/18.bedb26ac.js"><link rel="prefetch" href="/assets/js/19.d3a83c51.js"><link rel="prefetch" href="/assets/js/20.23f531bd.js"><link rel="prefetch" href="/assets/js/21.fa3a8b0b.js"><link rel="prefetch" href="/assets/js/22.dd42623f.js"><link rel="prefetch" href="/assets/js/23.14b22e09.js"><link rel="prefetch" href="/assets/js/24.2c357c2f.js"><link rel="prefetch" href="/assets/js/25.41f70192.js"><link rel="prefetch" href="/assets/js/26.5731662e.js"><link rel="prefetch" href="/assets/js/27.2c82e6f1.js"><link rel="prefetch" href="/assets/js/28.6b1e2679.js"><link rel="prefetch" href="/assets/js/29.52949168.js"><link rel="prefetch" href="/assets/js/30.642a0b42.js"><link rel="prefetch" href="/assets/js/31.b791d24d.js"><link rel="prefetch" href="/assets/js/32.bb1b2219.js"><link rel="prefetch" href="/assets/js/33.178d22ff.js"><link rel="prefetch" href="/assets/js/34.fdf98a86.js"><link rel="prefetch" href="/assets/js/35.6c50f535.js"><link rel="prefetch" href="/assets/js/36.cf1498bc.js"><link rel="prefetch" href="/assets/js/37.99716b8a.js"><link rel="prefetch" href="/assets/js/38.b2ce4bb0.js"><link rel="prefetch" href="/assets/js/39.8a8e230e.js"><link rel="prefetch" href="/assets/js/4.4a81d6b4.js"><link rel="prefetch" href="/assets/js/40.67b7ff19.js"><link rel="prefetch" href="/assets/js/41.af685904.js"><link rel="prefetch" href="/assets/js/42.0a535445.js"><link rel="prefetch" href="/assets/js/43.a4584be6.js"><link rel="prefetch" href="/assets/js/44.d38de00d.js"><link rel="prefetch" href="/assets/js/45.c069f685.js"><link rel="prefetch" href="/assets/js/46.c8d6e254.js"><link rel="prefetch" href="/assets/js/47.754247e3.js"><link rel="prefetch" href="/assets/js/48.93f86aa6.js"><link rel="prefetch" href="/assets/js/49.7163a1ff.js"><link rel="prefetch" href="/assets/js/5.f910a1bf.js"><link rel="prefetch" href="/assets/js/50.3d5e97f8.js"><link rel="prefetch" href="/assets/js/51.2a5093e6.js"><link rel="prefetch" href="/assets/js/52.104812a1.js"><link rel="prefetch" href="/assets/js/53.e69cd8d6.js"><link rel="prefetch" href="/assets/js/54.0cca4c91.js"><link rel="prefetch" href="/assets/js/55.aeac0434.js"><link rel="prefetch" href="/assets/js/56.9cf4cd0f.js"><link rel="prefetch" href="/assets/js/57.c90b6fc4.js"><link rel="prefetch" href="/assets/js/58.019fd5ca.js"><link rel="prefetch" href="/assets/js/59.02fecebf.js"><link rel="prefetch" href="/assets/js/6.1f62d07c.js"><link rel="prefetch" href="/assets/js/60.a850aea7.js"><link rel="prefetch" href="/assets/js/62.3e037f6e.js"><link rel="prefetch" href="/assets/js/63.75212b60.js"><link rel="prefetch" href="/assets/js/64.e1819b81.js"><link rel="prefetch" href="/assets/js/65.032bfc9a.js"><link rel="prefetch" href="/assets/js/66.38d6839f.js"><link rel="prefetch" href="/assets/js/67.9d1dd7ee.js"><link rel="prefetch" href="/assets/js/68.1eb05af5.js"><link rel="prefetch" href="/assets/js/69.76f141ed.js"><link rel="prefetch" href="/assets/js/7.c6358cc5.js"><link rel="prefetch" href="/assets/js/70.960e053c.js"><link rel="prefetch" href="/assets/js/71.6479bdcb.js"><link rel="prefetch" href="/assets/js/72.b82fea09.js"><link rel="prefetch" href="/assets/js/73.758a3fbf.js"><link rel="prefetch" href="/assets/js/74.3f831a2c.js"><link rel="prefetch" href="/assets/js/75.267bb238.js"><link rel="prefetch" href="/assets/js/8.c06d65ae.js"><link rel="prefetch" href="/assets/js/9.7993c8c8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c33c50c5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>усилの博客</h3> <p class="description" data-v-59e6cb88>The heart wants to persevere</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>усил</span>
          
        <span data-v-59e6cb88>2020 - </span>
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.png" alt="усилの博客" class="logo"> <span class="site-name">усилの博客</span></a> <div class="links"><div class="color-picker"><a class="color-button" style="display: none"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Electron 笔记/" class="nav-link"><i class="undefined"></i>
  Electron 笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/大学/" class="nav-link"><i class="undefined"></i>
  大学
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/React 笔记/" class="nav-link"><i class="undefined"></i>
  React 笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/Vue 笔记/" class="nav-link"><i class="undefined"></i>
  Vue 笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/工作/" class="nav-link"><i class="undefined"></i>
  工作
</a></li><li class="dropdown-item"><!----> <a href="/categories/Node/" class="nav-link"><i class="undefined"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/categories/课外学习/" class="nav-link"><i class="undefined"></i>
  课外学习
</a></li><li class="dropdown-item"><!----> <a href="/categories/打卡算法/" class="nav-link"><i class="undefined"></i>
  打卡算法
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div><div class="nav-item"><a href="/project/" class="nav-link"><i class="iconfont reco-coding"></i>
  项目集
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    усил
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>61</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>29</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Electron 笔记/" class="nav-link"><i class="undefined"></i>
  Electron 笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/大学/" class="nav-link"><i class="undefined"></i>
  大学
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/React 笔记/" class="nav-link"><i class="undefined"></i>
  React 笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/Vue 笔记/" class="nav-link"><i class="undefined"></i>
  Vue 笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/工作/" class="nav-link"><i class="undefined"></i>
  工作
</a></li><li class="dropdown-item"><!----> <a href="/categories/Node/" class="nav-link"><i class="undefined"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/categories/课外学习/" class="nav-link"><i class="undefined"></i>
  课外学习
</a></li><li class="dropdown-item"><!----> <a href="/categories/打卡算法/" class="nav-link"><i class="undefined"></i>
  打卡算法
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div><div class="nav-item"><a href="/project/" class="nav-link"><i class="iconfont reco-coding"></i>
  项目集
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>前端 计算机网络篇</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>усил</span>
          
        <span data-v-59e6cb88>2020 - </span>
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page" style="padding-right:0;"><div class="page-title" style="background-image:url(/assets/img/bg.2cfdbb33.svg);"><div class="page-info"><h1 class="title">前端 计算机网络篇</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>усилの博客</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2022/10/22</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>计算机网络</span></i></div></div></div> <section class="section" style="display:;"><div class="theme-reco-content content__default"><h4 id="http-和-https"><a href="#http-和-https" class="header-anchor">#</a> # http 和 https</h4> <p>1、http：超文本传输协议；https: 是以安全为目标的 HTTP 通道，在 HTTP 的基础下添加了 SSL</p> <p>2、http：明文传输；https：通过 SSL 进行加密，安全性比 http 要好</p> <p>3、http 是 80 端口；https 是 443 端口</p> <p>4、https：需要 ca 证书，费用高</p> <p>5、<strong>https 协议的工作原理</strong></p> <ul><li>客户端使用 https url 访问服务器（要求 web 服务器建立 ssl 链接）</li> <li>web 服务器接收到客户端的请求后，会将网站的证书（证书包含了公钥），返回给客户端。</li> <li>客户端接收后，客户端和 web 服务器开始协商 ssl 链接的安全等级（加密等级）</li> <li>达成一致后，建立会话密钥，然后通过<strong>网站的公钥来加密会话密钥，并传送到网站</strong></li> <li>web 服务器通过自己的<strong>私钥解密出会话密钥</strong></li> <li>web 服务器通过<strong>会话密钥加密与客户端之间的通信</strong></li></ul> <p><img src="https://img-blog.csdnimg.cn/d53db991002e4a48a1591e3450c6e761.jpeg#pic_center" alt="在这里插入图片描述"></p> <p>6、https 的缺点</p> <ul><li>握手阶段比较费事</li> <li>缓存不如 http 高效，会增加数据开销</li> <li>SSL 证书费用高</li></ul> <hr> <h4 id="tcp-和-udp-的区别"><a href="#tcp-和-udp-的区别" class="header-anchor">#</a> # TCP 和 UDP 的区别</h4> <p>1、<strong>TCP 是面向连接</strong>；<strong>UDP 是无连接的</strong>（即发送数据前无需先建立链接）‘</p> <p>2、TCP 提供可靠的服务（通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达）</p> <p>3、UDP 尽最大努力交付</p> <p>4、<strong>TCP 面向字节流</strong>；<strong>UDP 面向报文</strong>，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用）</p> <p>5、TCP 只能 1 对 1 的；UDP 支持 1 对 1，1 对多</p> <p>6、<strong>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节</strong></p> <hr> <h4 id="websocket-的实现和应用"><a href="#websocket-的实现和应用" class="header-anchor">#</a> # webSocket 的实现和应用</h4> <p>1、什么是 WebSocket</p> <ul><li>WebSocket 是一种协议，可以在单个 TCP 连接上进行<strong>全双工通信</strong>（可以让服务端主动向客户端推送数据）</li> <li>在 WebSocket 中，<strong>浏览器与服务器只需要完成一次握手，两者之间就可以创建持久性的连接并进行双向数据传输</strong></li></ul> <p>2、Websocket 握手环节</p> <ul><li>客户端向服务端发送请求</li> <li>服务端根据客户端的请求切换到 WebSocket 协议</li> <li>服务端告知客户端服务器可以发起 WebSocket 连接</li> <li>客户端发起连接的约定</li> <li>客户端检查服务端的响应</li> <li>服务端处理客户端连接</li></ul> <p><img src="https://img-blog.csdnimg.cn/6992e13a67fa45329f1c4870f2122363.png#pic_center" alt="在这里插入图片描述"></p> <hr> <h4 id="head-请求与-get-请求的区别"><a href="#head-请求与-get-请求的区别" class="header-anchor">#</a> # HEAD 请求与 GET 请求的区别</h4> <ul><li>HEAD 请求跟 GET 请求相同，同样能够拿到响应头，但是<strong>不返回数据实体</strong></li> <li>HEAD 请求通常是用来在下载文件之前，获取远程服务器上的文件信息</li></ul> <hr> <h4 id="bom-属性方法"><a href="#bom-属性方法" class="header-anchor">#</a> # BOM 属性方法</h4> <p>1、location 对象</p> <ul><li>location.href -- 返回或设置当前文档的 URL</li> <li>location.search -- 返回 URL 中的查询字符串部分（?id=5&amp;name=haohao）</li> <li>location.hash -- 返回 URL#后面的内容</li> <li>location.host -- 返回 URL 中域名部分（www.baidu.com）</li> <li>location.hostname -- 返回 URL 中主域名部分（baidu.com）</li> <li>location.pathname -- 返回 URL 域名后的部分（www.baidu.com/a 返回/a）</li> <li>location.port -- 端口号</li> <li>location.port -- 协议</li> <li>location.assign -- 设置当前文档的 URL</li> <li>location.replace -- 设置当前文档的 URL（并且在 history 对象的地址列表中移除这个 url）</li> <li>location.reload() -- 重载当前页面</li></ul> <p>2、history 对象</p> <ul><li>history.go() -- 前进或后退指定的页面数</li> <li>history.back() -- 后退一页</li> <li>history.forward() -- 前进一页</li></ul> <p>3、navigator 对象</p> <ul><li><p>navigator.useAgent -- 返回用户代理头的字符串</p></li> <li><p>navigator.cookieEnabled -- 返回浏览器是否支持（启用）cookie</p></li></ul> <hr> <h4 id="html5-拖拽-api"><a href="#html5-拖拽-api" class="header-anchor">#</a> # HTML5 拖拽 api</h4> <ul><li>dragstart： 事件主体是被拖放元素，在开始拖放时触发</li> <li>drag：事件主体是被拖放元素，正在拖放时触发</li> <li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发</li> <li>dragover：事件主体是目标元素，在被拖放元素在某元素内移动时触发</li> <li>dragleave：事件主体是目标元素，在被拖放元素移出某元素时触发</li> <li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发</li> <li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</li></ul> <hr> <h4 id="http2-0"><a href="#http2-0" class="header-anchor">#</a> # http2.0</h4> <p>1、http2.0 是基于 1999 年发布的 http1.0 之后的首次更新</p> <p>2、请求资源所需时间更少，访问速度更快</p> <p>3、二进制分帧（在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层）</p> <ul><li>帧：HTTP2.0 通信的最小单位，所有帧都共享一个 8 字节的首部</li> <li>消息：比帧大的通信单位，是指逻辑上的 HTTP 消息，比如请求、响应等。由一个或多个帧组成</li> <li>流：比消息大的通信得。是 TCP 连接中的一个虚拟通道，可以承载双向的消息。每一个流都有唯一的整数标识符</li></ul> <p><strong>在 http1.x 中传输数据使用的是文本传输数据</strong>；基于文本传输数据存在很多缺陷。而二进制不同，只有 0 和 1 的组合</p> <p>在 http2.0 中所有传输的数据都会<strong>被分割为更小的消息和帧，并采用二进制格式编码</strong></p> <p>在 http1.x 的首部信息会被封装到 Headers 帧中，而 Rquest Body 则封装搭配 Data 帧中。</p> <p>4、首部压缩</p> <p>http1.x 中并不支持首部压缩；在 http2.0 中则支持，使用首部压缩的算法是 HPACK 算法</p> <p>在 http1.x 中，使用的是文本形式进行传输，如果在 header 中需要携带 cookie,则每次传输都传输重复数据</p> <p>在 http2.0 中，除了通过使用压缩算法压缩首部信息外，在客户端以及服务端都会维护一张<strong>索引表</strong>（用于记录曾经出现过的 header），在后面请求过程中可以重复使用 header。而对于接收端就可以通过键名找到对应的值</p> <p>5、多路复用</p> <p>在 http1.x 中由于<strong>浏览器限制同一个域名下的请求数量</strong>。因此，在页面需要请求很多资源时，队头会出现阻塞，只有等待前面资源加载完毕后才会加载下一个资源。</p> <p>而在 http2.0 中，基于二进制分帧，将 http 消息拆分成独立的帧（在不破坏信息的前提下），<strong>交错发出</strong>。而在另外一端根据流标识符和首部将这些帧重新组装。</p> <p>6、请求优先级</p> <p>把 HTTP 消息分为很多独立帧之后，就可以通过<strong>优化这些帧的交错和传输顺序进一步优化性能</strong>。</p> <p>7、服务器推送</p> <p><strong>服务器可以对一个客户端请求发送多个响应</strong></p> <p>比如：</p> <ul><li>客户端请求资源 1，服务端在响应资源 1 的同时再次推送资源 2、资源 3</li> <li>如果该请求是从主页发出的，服务端可能会响应主页内容、logo 以及样式表</li></ul> <p>缺点：<strong>所有推送资源必须遵守同源策略</strong></p> <hr> <h4 id="_400、401、403-状态码"><a href="#_400、401、403-状态码" class="header-anchor">#</a> # 400、401、403 状态码</h4> <p>1、400：请求无效</p> <ul><li>可能产生的原因：前端提交数据的字段名称和字段类型与后台的实体没有保持一致</li></ul> <p>2、401：当前请求需要用户验证</p> <p>3、403：服务器已经得到请求，但拒绝执行</p> <hr> <h4 id="fetch-发送-2-次请求的原因"><a href="#fetch-发送-2-次请求的原因" class="header-anchor">#</a> # fetch 发送 2 次请求的原因</h4> <p>1、在跨域请求的情况下，fetch 会先发送一个 options 请求，来确定服务器是否允许接受请求。服务区同意后，才会发送真正的请求。</p> <p>2、在同源情况下不会出现请求 2 次的情况</p> <hr> <h4 id="cookie、sessionstorage、localstorage-的区别"><a href="#cookie、sessionstorage、localstorage-的区别" class="header-anchor">#</a> # Cookie、sessionStorage、localStorage 的区别</h4> <p>1、共同点：都是保存在浏览器中，并且是同源的</p> <p>2、不同点：</p> <p>（1）存储位置及其传输</p> <ul><li>cookie： 数据始终在同源的 http 请求中携带，并且 cookie 数据中有路径的概念，可以限制 cookie 只属于某一个路径下</li> <li>sessionStorage：浏览器中（不会发送给服务器）</li> <li>localStorage：浏览器中（不会发送给服务器）</li></ul> <p>（2）时效性</p> <ul><li>cookie：只要设置了过期时间，在这之前都有效</li> <li>sessionStorage：仅在当前浏览器窗口关闭前有效</li> <li>localStorage：持久保存，当窗口或者浏览器关闭也会一直保存</li></ul> <p>（3）共享性</p> <ul><li>cookie：在所有同源窗口中都是共享的</li> <li>sessionStorage：在所有同源窗口中都是共享的</li> <li>localStorage：在所有同源窗口中都是共享的</li></ul> <hr> <h4 id="web-worker"><a href="#web-worker" class="header-anchor">#</a> # web worker</h4> <p>Web Workers 使得一个 Web 应用程序可以在与主线程分离的后台线程中运行一个脚本。</p> <p>这样做的好处在于可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是 UI）线程运行而不被阻塞</p> <blockquote><p>它的作用就是给 JS 创造多线程运行环境，允许主线程创建 worker 线程，分配任务给后者，主线程运行的同时 worker 线程也在运行，相互不干扰，在 worker 线程运行结束后把结果返回给主线程。这样做的好处是主线程可以把计算密集型或高延迟的任务交给 worker 线程执行，这样主线程就会变得轻松，不会被阻塞或拖慢。这并不意味着 JS 语言本身支持了多线程能力，而是浏览器作为宿主环境提供了 JS 一个多线程运行的环境。</p> <p>不过因为 worker 一旦新建，就会一直运行，不会被主线程的活动打断，这样有利于随时响应主线程的通性，但是也会造成资源的浪费，所以不应过度使用，用完注意关闭。或者说：如果 worker 无实例引用，该 worker 空闲后立即会被关闭；如果 worker 实列引用不为 0，该 worker 空闲也不会被关闭。</p></blockquote> <hr> <h4 id="html5-语义化标签"><a href="#html5-语义化标签" class="header-anchor">#</a> # HTML5 语义化标签</h4> <p>HTML5 语义化标签指的是：在没有 css 的作用下，单纯通过 html 标签能够表达出网页的具体内容。比如：article 标签用于段落，header 为头部等等</p> <hr> <h4 id="iframe-是什么-有什么缺点"><a href="#iframe-是什么-有什么缺点" class="header-anchor">#</a> # iframe 是什么？有什么缺点</h4> <p>1、iframe 也称作嵌入式框架，可以把网页的内容嵌入到 iframe</p> <p>优点：</p> <ul><li>iframe 能够原封不动的把嵌入的网页展现出来</li> <li>如果遇到加载缓慢的第三方内容（图标、广告），这些问题可以使用 iframe 来解决</li></ul> <p>缺点：</p> <ul><li>iframe 会阻塞主页面的 onload 事件</li> <li>iframe 和主页面共享连接池，而浏览器对相同域的连接限制，所以会影响页面的并行加载。</li> <li>代码复杂，无法被一些搜索引擎索引到</li> <li>很多移动设备无法完全显示框架唉，设备兼容性差</li> <li>iframe 框架页面会增加服务器的 http 请求</li></ul> <hr> <h4 id="什么是-doctype-严格模式与混杂模式的区别"><a href="#什么是-doctype-严格模式与混杂模式的区别" class="header-anchor">#</a> # 什么是 Doctype？ 严格模式与混杂模式的区别？</h4> <p>1、声明位于文档中的最前面位置，处于标签之前</p> <p>2、告知浏览器文档使用哪种 HTML 或 XHTML 规范</p> <p>3、重点：告知浏览器按照何种规范解析页面</p> <p>4、严格模式下：页面排版及 JS 解析是以该浏览器支持的最高标志来执行</p> <p>5、混杂模式下：不严格按照标志执行，主要用来兼容旧浏览器，向后兼容</p> <p>6、Doctype 不存在或格式不正确会导致文档以混杂模式呈现</p> <hr> <h4 id="cookie-如何防范-xss-攻击"><a href="#cookie-如何防范-xss-攻击" class="header-anchor">#</a> # Cookie 如何防范 XSS 攻击</h4> <p>XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本。</p> <p>可以在头部设置 set-cookie=httponly; secure</p> <ul><li>httponly：这个属性可以防止 XSS，它会禁止 javascript 脚本来访问 cookie</li> <li>secure：这个属性告诉浏览器仅在请求为 https 的时候发送 cookie</li></ul> <hr> <h4 id="http-缓存"><a href="#http-缓存" class="header-anchor">#</a> # http 缓存</h4> <p><img src="https://img-blog.csdnimg.cn/cce96b1f17fc4702b95962c370b70928.jpeg#pic_center" alt="在这里插入图片描述"></p> <p><strong>http 缓存都是从第二次请求开始的</strong></p> <p>流程：</p> <p>1、第一次请求资源时，服务器返回资源，并在响应头部中注入回传资源的缓存参数</p> <blockquote><p>如：</p> <p>Cache-Control: max-age=31536000 单位是 s（http1.1）</p> <p>expires （http1.0）</p> <p>优先级：Cache-Control &gt; expires</p></blockquote> <p><img src="https://img-blog.csdnimg.cn/dd291f62ab4a42eaace42b018b648d35.png#pic_center" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/e1d822dbd50147369534b9dd3ba2916c.png#pic_center" alt="在这里插入图片描述"></p> <table><thead><tr><th>选项</th> <th>解释</th></tr></thead> <tbody><tr><td>max-age=100</td> <td>缓存 100 秒后过期，资源缓存在本地</td></tr> <tr><td>no-cache</td> <td>不使用本地缓存。使用协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务器验证，如果资源未被更改，那可以避免重新下载</td></tr> <tr><td>no-store</td> <td>所有内容都不会被缓存，既不使用强制缓存也不使用协商缓存，每次用户请求该资源，都会向服务器发送请求，服务器再返回资源</td></tr> <tr><td>public</td> <td>可以被所有的用户缓存，包括客户端和代理服务器</td></tr> <tr><td>private</td> <td>只能被客户端缓存，不允许 CDN 等中继续存服务器对其缓存</td></tr> <tr><td>s-maxage</td> <td>覆盖 max-age，作用与 max-age 一样，但只用于代理服务器中缓存</td></tr></tbody></table> <p>第一次请求：</p> <p><img src="https://img-blog.csdnimg.cn/813906eac82c47c1803f73072aaa277e.png#pic_center" alt="在这里插入图片描述"></p> <p>2、第二次请求时（相同资源），浏览器会先查看该资源的缓存参数，通过判断 <code>max-age=315360000</code>是否过期，<strong>未过期则命中强缓存，不会向后端发送请求</strong>。否则就把请求参数注入到请求头部传给服务器</p> <p>第二次请求：
<img src="https://img-blog.csdnimg.cn/a4ac61b5c8bc449abe8c3880c92263fe.png#pic_center" alt="在这里插入图片描述"></p> <p>补充知识点：</p> <ul><li>from memory cache 代表使用内存中的缓存</li> <li>from disk cache 代表使用硬盘中的缓存</li></ul> <p>浏览器加载顺序为 memory -&gt; disk</p> <p>在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中；而 css 文件存放在硬盘中的缓存中</p> <p><img src="https://img-blog.csdnimg.cn/29b7ea24af4144f69c3c90c87260f762.png#pic_center" alt="在这里插入图片描述"></p> <p><img src="https://img-blog.csdnimg.cn/7961f3289a2f4c01b869e63f5ff2c450.png#pic_center" alt="在这里插入图片描述">
强缓存的这种方式页面加载速度是最快的，性能也是最好的，但是在这期间必须保证线上资源没有被修改</p> <p>3、到达服务器，看是否命中协商缓存，命中则返回 304，否则服务器会返回新的资源</p> <p><strong>常见的 http 缓存只能缓存 get 请求响应的资源</strong></p> <hr> <h4 id="协商缓存-对比缓存"><a href="#协商缓存-对比缓存" class="header-anchor">#</a> # 协商缓存（对比缓存）</h4> <p><strong>协商缓存是一种服务端缓存策略</strong></p> <p>流程：</p> <p>1、如果服务器使用协商缓存，第一次发送请求从服务端获取到资源后，会将资源在本地进行缓存。并且服务端还会返回资源标识符。</p> <p>2、再次发送请求时（会携带资源标识符）。此时服务器通过标识符判断浏览器中的资源版本是否与服务器中最新的资源版本是否一致。</p> <p>3、若一致，<strong>服务器就会返回给浏览器 304 的状态码</strong>，重定向让浏览器直接从本地缓存中去取资源</p> <p>4、若不一致，服务器就会返回给浏览器 200 的状态码，并且返回最新的资源和新的资源标识符</p> <p>补充：</p> <p>资源标识符：</p> <ul><li><p><code>Last-Modified/If-Modified-Since</code>：指资源上一次修改的时间（精确到秒）</p></li> <li><p><code>Etag/If-None-Match</code>：资源对应的唯一字符串（只要文件内容不同，对应的 Etag 就一定会发生变化）</p></li></ul> <p>为什么需要使用 Etag 来判断文件是否修改</p> <p>如果在浏览器本地缓存中缓存了文件，若后台打开了该文件，并进行编辑，但最终保存内容没有发生变化，但此时<code>Last-Modified/If-Modified-Since</code>已经更新修改时间。</p> <p>再次请求该资源时，通过判断 <code>Last-Modified/If-Modified-Since</code>就会出现下载相同文件，浪费带宽。</p> <p>因此<code>Etag/If-None-Match</code>就应运而生，服务器会先验证<code>ETag</code>，一致的情况下，才会判断<code>Last-Modified/If-Modified-Since</code>，最后才决定是否返回 304</p> <hr> <h4 id="强缓存和协商缓存的对比"><a href="#强缓存和协商缓存的对比" class="header-anchor">#</a> # 强缓存和协商缓存的对比</h4> <table><thead><tr><th></th> <th>强缓存</th> <th>协商缓存</th></tr></thead> <tbody><tr><td>缓存存放位置</td> <td>本地浏览器</td> <td>本地浏览器</td></tr> <tr><td>http 状态码</td> <td>200</td> <td>304</td></tr> <tr><td>谁来决定</td> <td>Cache-Control<br>Expires</td> <td>ETag/If-Not-Match<br>Last-Modified/If-Modified-Since</td></tr> <tr><td>操作是否有效</td> <td>1、Ctrl+F5 强制刷新（无效）<br>2、F5 刷新（无效）<br>3、地址栏回车（有效）<br>4、页面链接跳转（有效）<br>5、新开窗口（有效）<br>6、前进、后退（有效）</td> <td>1、Ctrl+F5 强制刷新（无效）<br>2、F5 刷新（有效）<br>3、地址栏回车（有效）<br>4、页面链接跳转（有效）<br>5、新开窗口（有效）<br>6、前进、后退（有效）</td></tr></tbody></table> <hr> <h4 id="前端优化手段"><a href="#前端优化手段" class="header-anchor">#</a> # 前端优化手段</h4> <ul><li>降低请求量：合并资源，减少 HTTP 请求数，minify/gzip 压缩，webP，lazyLoad</li> <li>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发</li> <li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage</li> <li>渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline</li></ul> <hr> <h4 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> # GET 和 POST 的区别</h4> <ul><li><p>GET 参数通过 URL 传递，POST 参数放在 request body 中</p></li> <li><p>GET 请求在 URL 中传递的参数是有长度限制的，而 POST 没有</p></li> <li><p>POST 比 GET 更安全</p></li> <li><p>GET 请求只能进行 URL 编码，而 POST 支持多种编码方式</p></li> <li><p>GET 请求参数会被完整保留在浏览历史记录里，而 POST 的参数不会被保留</p></li> <li><p>GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包</p></li></ul> <blockquote><p>对于 GET 浏览器会把 http header 和 data 一并发送出去，服务器返回数据</p> <p>对于 POST 浏览器会先发送 header，再发送 data，服务器返回数据</p></blockquote> <hr> <h4 id="_301-和-302-的区别"><a href="#_301-和-302-的区别" class="header-anchor">#</a> # 301 和 302 的区别</h4> <ul><li>301：永久重定向（被请求的资源已永久移动到新位置）</li> <li>302：临时重定向（被请求的资源临时移动到新位置）</li></ul> <hr> <h4 id="html5-新增的元素"><a href="#html5-新增的元素" class="header-anchor">#</a> # HTML5 新增的元素</h4> <ul><li>语义化标签：header、footer、nav、aside、section</li> <li>表单：input 增加了 color、email、data、range</li> <li>存储：sessionStorage、localStorage、离线存储</li> <li>多媒体：audio、vedio</li> <li>地理定位</li> <li>canvas 画布</li> <li>拖放</li> <li>多线程编程的 web worker</li> <li>websocket 协议</li></ul> <hr> <h4 id="在地址栏里输入-url-到这个页面呈现出来-中间发生什么"><a href="#在地址栏里输入-url-到这个页面呈现出来-中间发生什么" class="header-anchor">#</a> # 在地址栏里输入 URL，到这个页面呈现出来，中间发生什么？</h4> <p><img src="https://img-blog.csdnimg.cn/99f2dcb8ca3b4130b02ccaf6f9c87e74.jpeg#pic_center" alt="在这里插入图片描述"></p> <p>1、输入 url 后，需要通过 url 找到其服务器的 ip，为了找到该 ip</p> <p>2、浏览器会先寻找缓存，<strong>查看缓存中是否有记录</strong>（浏览器缓存 =》 系统缓存 =》 路由缓存）</p> <p>3、若没找到，<strong>再次查找系统的 hosts 文件 中是否有记录</strong></p> <p>4、最终没有，则查询 DNS 服务器，得到 ip 后</p> <p>5、浏览器会根据 ip 以及端口号，构造一个 http 请求，并将这个<strong>请求封装在一个 TCP 包</strong>中</p> <p>6、这包会经过<strong>传输层，网络层，数据链路层，物理层，最终到达服务器</strong></p> <p>7、服务器接收到该请求后，进行解析，返回相应的 html 给到浏览器</p> <p>8、浏览器根据 html 来构建 <strong>DOM 树</strong>，如果在构建过程中遇到 js 脚本或外部 js 链接，则会停止 DOM 树，来执行和下载 js 代码，这就会造成阻塞</p> <p>9、之后，根据外部样式，内部样式，内联样式构建一个<strong>CSS 对象模型树 CSSOM 树</strong></p> <p>10，构建完成后和 DOM 树合并为渲染树（这一步的操作只要是排除非视觉节点，比如<code>script</code>,<code>meta</code>以及 displa 为 none 的节点）</p> <p>11、最后进行布局（确定各个元素的位置和尺寸）</p> <p>12、由于 hrml 文件可能存在图片，视频，音频等资源，在构建 DOM 树 过程中，遇到这些都会进行并行下载。</p> <p>13、浏览器对每个于的并行下载数量有一定的限制（4~6）</p> <p>14、在这下载过程优化的过程中，就可能涉及到强缓存或协商缓存</p> <hr> <h4 id="csrf-和-xss"><a href="#csrf-和-xss" class="header-anchor">#</a> # CSRF 和 XSS</h4> <p>XSS（跨站脚本攻击）是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行，获取敏感信息（Cookie、sessionID）</p> <p>CSRF（跨站请求伪造）攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨域请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的</p> <p>XSS 预防手段：对输入的 URL 以及参数进行过滤，过滤掉导致脚本执行的相关内容；对动态输入到页面的内容进行 html 编码，使脚本无法在浏览器中执行</p> <p>CSRF 防御手段：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证</p> <hr> <h4 id="http-常用的请求方式-区别和用途"><a href="#http-常用的请求方式-区别和用途" class="header-anchor">#</a> # HTTP 常用的请求方式，区别和用途</h4> <table><thead><tr><th>请求方式</th> <th>用途</th></tr></thead> <tbody><tr><td>GET</td> <td>对服务器资源获取的简单请求</td></tr> <tr><td>POST</td> <td>用于发送包含用户提交数据的请求</td></tr> <tr><td>PUT</td> <td>向服务器提交数据，以修改数据</td></tr> <tr><td>HEAD</td> <td>请求页面首部，获取资源的元信息</td></tr> <tr><td>DELETE</td> <td>删除服务器上的某些资源</td></tr> <tr><td>CONNECT</td> <td>用于 ssl 隧道的基于代理的请求</td></tr> <tr><td>OPTIONS</td> <td>返回所有可用的方法，常用于跨域</td></tr> <tr><td>TRACE</td> <td>追踪请求-响应的传输路径</td></tr></tbody></table> <h4 id="网络端口及对应的服务"><a href="#网络端口及对应的服务" class="header-anchor">#</a> # 网络端口及对应的服务</h4> <table><thead><tr><th>端口</th> <th>服务</th></tr></thead> <tbody><tr><td>21</td> <td>FTP（文件传输协议）</td></tr> <tr><td>22</td> <td>SSH</td></tr> <tr><td>23</td> <td>Telnet（远程登录）服务</td></tr> <tr><td>53</td> <td>DNS 域名服务器</td></tr> <tr><td>80</td> <td>HTTP 超文本传输协议</td></tr> <tr><td>443</td> <td>HTTPS</td></tr> <tr><td>1521</td> <td>Oracle 数据库默认端口</td></tr> <tr><td>3306</td> <td>Mysql 服务默认端口</td></tr></tbody></table> <hr> <h4 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="header-anchor">#</a> # 计算机网络体系结构</h4> <p><img src="https://img-blog.csdnimg.cn/c4b5ba2b7a6c45509988385b020426ad.jpeg#pic_center" alt="在这里插入图片描述"></p> <hr> <h4 id="在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持"><a href="#在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" class="header-anchor">#</a> # 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</h4> <p>在 HTTP 中响应体的<strong>Connection</strong>字段指定为 keep-alive 即可</p> <hr> <h4 id="http-的长连接与短连接"><a href="#http-的长连接与短连接" class="header-anchor">#</a> # HTTP 的长连接与短连接</h4> <p>1、在长连接出现之前，http1.0 中都是使用的短连接，其特点是一次 http 交互完成后就会断开连接。由于 http 协议是基于 TCP 协议的，而 TCP 协议有三次握手四次挥手来建立以及断开连接，那么面对多次的 http 请求，这种短连接就会造成多次的握手以及挥手资源浪费，正是因为这个问题才出现了长连接。</p> <p>2、在 http1.1 中，出现了 http 长连接，其特点是保持连接特性，当一次 http 交互完后该 TCP 通道并不会关闭，而是会保持一段时间(在不同服务器上时间不一样，可以设置)，如果在这段时间内再次发起了 http 请求就可以直接复用，而不用重新进行握手，从而减少了资源浪费。目前 http1.1 中，都是默认使用长连接</p> <p>3、设置长连接：在请求头上添加<code>connection：keep-alive</code></p> <hr> <h4 id="什么是数字签名、数字证书"><a href="#什么是数字签名、数字证书" class="header-anchor">#</a> # 什么是数字签名、数字证书</h4> <p>数字证书是指在互联网通讯中<strong>标志通讯各方身份信息的一个数字认证</strong></p> <p>人们可以在网上用它来识别对方的身份。它的出现，是为了避免身份被篡改冒充的。</p> <hr> <h4 id="对称加密与非对称加密有什么区别"><a href="#对称加密与非对称加密有什么区别" class="header-anchor">#</a> # 对称加密与非对称加密有什么区别</h4> <p>对称加密：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES</p> <p>非对称加密：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。</p> <hr> <h4 id="五层计算机网络体系结构中-每一层对应的网络协议有哪些"><a href="#五层计算机网络体系结构中-每一层对应的网络协议有哪些" class="header-anchor">#</a> # 五层计算机网络体系结构中，每一层对应的网络协议有哪些？</h4> <p>应用层</p> <ul><li>HTTP ：超文本传输协议</li> <li>FTP：文本传输协议</li> <li>SMTP：简单邮件传输协议</li> <li>DNS：域名系统</li> <li>SSH：安全外壳协议</li> <li>DHCP：远程登录协议</li></ul> <p>传输层</p> <ul><li>TCP：传输控制协议</li> <li>UDP：用户数据报文协议</li></ul> <p>网络层</p> <ul><li>IP：网际协议</li> <li>ARP：地址转换协议</li> <li>RARP：反向地址转换协议</li> <li>ICMP：Internet 组管理协议</li> <li>RIP：路由信息协议</li> <li>OSPF：分布式链路状态协议</li> <li>BGP：边界网关协议</li></ul> <p>数据链路层</p> <ul><li>ARQ：自动重传请求协议</li> <li>CSMA/CD：停止等待协议</li> <li>PPP：点对点协议</li></ul> <p>物理层</p> <ul><li>HUB</li> <li>网线</li> <li>中继器</li></ul> <hr> <h4 id="websocket-与-socket-的区别"><a href="#websocket-与-socket-的区别" class="header-anchor">#</a> # WebSocket 与 socket 的区别</h4> <p>Socket = IP 地址 + 端口 + 协议</p> <p>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决<strong>http 不支持持久化连接</strong>的问题</p> <hr> <h4 id="http-请求的过程与原理"><a href="#http-请求的过程与原理" class="header-anchor">#</a> # Http 请求的过程与原理</h4> <p>1、客户端进行 DNS 域名解析，得到对应的 IP 地址</p> <p>2、根据这 IP，找到对应服务器建立连接（三次握手）</p> <p>3、建立 TCP 连接后发起 HTTP 请求（一个完整的 http 请求报文）</p> <p>4、服务器响应 HTTP 请求，客户端得到 html 代码</p> <p>5、客户端解析 html 代码，用 html 代码中的资源渲染页面</p> <p>6、服务器关闭 TCP 连接（四处挥手）</p> <hr> <h4 id="forward-和-redirect-的区别"><a href="#forward-和-redirect-的区别" class="header-anchor">#</a> # forward 和 redirect 的区别</h4> <p>forward（直接转发）客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</p> <p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-endA4RI5-1666403638584)(面试题/607a9988b05ead576191bced8c0ef99.jpg)]</p> <p>redirect（间接转发）实际是两次 HTTP 请求服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的</p> <p><img src="https://img-blog.csdnimg.cn/980ce28431c54d0aaf40775c328e2a24.jpeg#pic_center" alt="在这里插入图片描述"></p> <hr> <h4 id="dns-解析过程"><a href="#dns-解析过程" class="header-anchor">#</a> # DNS 解析过程</h4> <p>以解析 <code>www.csdn.net</code>为例：</p> <p>1、首先会查询浏览器缓存是否能找到<code>www.csdn.net</code>对应的 IP 地址，找到直接返回，否则进行下一步</p> <p>2、将请求发往本地 DNS 服务器，如果查到到也直接返回，否则继续进行下一步</p> <p>3、本地 DNS 服务器向<strong>根域名服务器</strong>发送请求，根域名服务器返回负责<code>.com</code> 的顶级域名服务器的 IP 地址列表</p> <p>4、本 DNS 服务器再向其中一个复杂**.com**的顶级服务器发送一个请求，返回负责<code>.baidu</code>的顶级域名服务器的 IP 地址列表</p> <p>5、本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，返回<code>www.baidu.com</code>所对应的 IP 地址</p> <hr></div></section></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:0;" data-v-b57cc07c data-v-7dd95ae2></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.7286f64f.js" defer></script><script src="/assets/js/3.827211db.js" defer></script><script src="/assets/js/1.5fd42fbd.js" defer></script><script src="/assets/js/61.2ae32b4f.js" defer></script>
  </body>
</html>
